<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Core-to-Core Latency: Meteor Lake vs. Phoenix vs. Raptor Lake - QuickBlog</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="As the core count of modern CPUs is growing, we are reaching a time when the time to access each core from a different core is no longer a constant. Even before the advent of heterogeneous SoC designs, processors built on large rings or meshes can have different latencies to access the nearest core compared"><meta name=robots content="index,follow,noarchive"><meta property="og:title" content="Core-to-Core Latency: Meteor Lake vs. Phoenix vs. Raptor Lake"><meta property="og:description" content="As the core count of modern CPUs is growing, we are reaching a time when the time to access each core from a different core is no longer a constant. Even before the advent of heterogeneous SoC designs, processors built on large rings or meshes can have different latencies to access the nearest core compared"><meta property="og:type" content="article"><meta property="og:url" content="/intel-core-ultra-7-115h-review-meteor-lake-makes-makes-fresh-start-to-mobile-cpus.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-10T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-10T00:00:00+00:00"><meta itemprop=name content="Core-to-Core Latency: Meteor Lake vs. Phoenix vs. Raptor Lake"><meta itemprop=description content="As the core count of modern CPUs is growing, we are reaching a time when the time to access each core from a different core is no longer a constant. Even before the advent of heterogeneous SoC designs, processors built on large rings or meshes can have different latencies to access the nearest core compared"><meta itemprop=datePublished content="2024-08-10T00:00:00+00:00"><meta itemprop=dateModified content="2024-08-10T00:00:00+00:00"><meta itemprop=wordCount content="1302"><meta itemprop=keywords content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/mainroad/css/style.css><link rel="shortcut icon" href=./favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=./index.html title=QuickBlog rel=home><div class="logo__item logo__text"><div class=logo__title>QuickBlog</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Core-to-Core Latency: Meteor Lake vs. Phoenix vs. Raptor Lake</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-08-10T00:00:00Z>August 10, 2024</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=./categories/blog/ rel=category>blog</a></span></div></div></header><div class="content post__content clearfix"><h2>Core-to-Core Latency: Meteor Lake vs.&nbsp;Phoenix vs. Raptor Lake</h2><p>As the core count of modern CPUs is growing, we are reaching a time when the time to access each core from a different core is no longer a constant. Even before the advent of heterogeneous SoC designs, processors built on large rings or meshes can have different latencies to access the nearest core compared to the furthest core. This rings true especially in multi-socket server environments.</p><p>But modern CPUs, even desktop and consumer CPUs, can have variable access latency to get to another core. For example, in the first generation Threadripper CPUs, we had four chips on the package, each with 8 threads, and each with a different core-to-core latency depending on if it was on-die or off-die. This gets more complex with products like Lakefield, which has two different communication buses depending on which core is talking to which.</p><p>If you are a regular reader of AnandTech’s CPU reviews, you will recognize our Core-to-Core latency test. It’s a great way to show exactly how groups of cores are laid out on the silicon. This is a custom in-house test, and we know there are competing tests out there, but we feel ours is the most accurate to how quick an access between two cores can happen.</p><p>In this core-to-core latency analysis, we'll compare the Intel Core Ultra 7 155H, based on their latest Meteor Lake architecture, directly to a similar processor from Raptor Lake, the Core i5-14600K. Both have the same 6P+8E core configuration, with the Core Ultra 7 155H coming with two Low Power Island (LP) Efficiency cores embedded within the SoC.</p><p>These LP E cores are based on the same Crestmont microarchitecture as the larger Efficiency cores within the compute tile but are designed to operate with a lower voltage-to-frequency (V/F) curve, emphasizing that they are designed to operate at an overall lower power envelope. The key idea is that the LP E cores offload the lightest and least demanding background tasks with the aid of Intel's Thread Director&nbsp;– and ideally, avoid powering up the compute tile altogether for mundane background threads.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/21282/Intel%20Core%20Ultra%207%20155H%20Core%20to%20Core%20Latency_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>(Click to enlarge)</p><p>Looking at the core-to-core latencies of the Intel Core Ultra 7 155H, which showcases the physical topology of the processor itself, there are a couple of interesting points to note. Firstly, Intel's Meteor Lake compute tile with both the P-core and E-cores that are built on the Intel 4 node employ&nbsp;a similar bi-directional cache coherence as per its previous architectures, such as Alder Lake and Raptor Lake. From Intel's previous heterogeneous architectures, such as Alder Lake and Raptor Lake,</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/21282/Intel%20Core%20i5-14600K%20Core%20to%20Core%20Latency_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>(Click to enlarge)</p><p>Starting with the Redwood Cove (P) core cluster on the Core Ultra 7 155H, we can see that the inter-core latency access latencies across the P-cores range from 4.5 to 4.9 ns, which is very similar to that of Raptor Lake via the Core i5-14600K, which sits between 4.6 and 4.9 ns; this indicates that both have a very similar&nbsp;topology. Interestingly, Intel has placed a single P-core at the front of the topology, which has an inter-core&nbsp;latency of 5 ns. Going outside to contact other cores, the latency increases within the P-Core cluster up to 39.9 ns, which is very similar to Raptor Lake.</p><p>For the E-cores, the latencies shoot up to between 57.9 and 74.8 ns per each L1 access point, with the two first E-cores having a latency of just 5.0 ns. For reference, the Core i5-14600K, which is based on Raptor Lake, has lower efficiency core-to-core latencies of between 41.5 and 46 ns. Outside of the initial L1 access, the latencies shoot up, as expected, to between 45.2 and 75.4 ns at the top end of the scale.&nbsp;</p><p>Lastly, the Low-Power Island E-cores are designated as Core 20 and 21. They have much higher latencies of up to 152 ns, which isn't very efficient when communicating with cores in other clusters. They also have the longest route to take to reach any other core clusters, since they need to go off-die over to the compute tile to talk to the rest of the CPU cores. However, even between themselves, the core-to-core latency is still high, at 116.8 ns. This strongly emphasizes how the LP cores are not meant to be treated as part of the larger pool of CPU cores for multi-threaded tasks, and instead are best left to handle background activities.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/21282/AMD%20Ryzen%209%207940HS%20Core%20to%20Core%20Latency%202_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>(Click to enlarge)</p><p>Throwing AMD's Ryzen 9 7940HS into the mix, the Phoenix architecture uses AMD's Zen 4 cores on an FP8 chipset and is built using TSMC's 4 nm node. With a monolithic core and cache coherency structure, the inter-core-to-core latencies on this chip are higher than Intel's P-Core cluster on both Meteor Lake and Raptor Lake, with a consistent L1 range of between 7.0 and 7.1 ns. Hopping between other cores within the cluster on the Ryzen 9 7940HS, latencies hit up to 20.8 ns, which is much lower overall than the heterogeneous architecture Intel is using with P and E-cores while adding the LP E cores into the mix to push these latencies higher.</p><h3>Cache Latencies</h3><p align=center><a href=# id=lat1a><img alt id=lat1i src=https://cdn.statically.io/img/images.anandtech.com/doci/21282/Latency-MTL-CU7-155H.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Examining the Core Ultra 7 155H's memory latency&nbsp;with LPDDR5X, the above graph looks at&nbsp;various test depths and shows the impact on latency through the different levels of cache.&nbsp;The baseline latency for linear memory access patterns remains consistently the lowest, with efficient[&nbsp;prefetchers in using predictable patterns,</p><p>Across random access scenarios, the full random test exhibits higher latency across all depths, highlighting the increased time required for memory accesses when they are not sequential. This is a common&nbsp;challenge for CPUs when dealing with unpredictable data access, which is more typical than not within&nbsp;many real-world applications.</p><p>Latency inherently shoots skyward when we cross the L1 and L2 cache thresholds, as evident from the latency jumps at specific test depths. An example of this is at the 1024 KB test depth, where we can see an increase in&nbsp;latency for random access patterns. This means that the test depth exceeds the capability of the cache,&nbsp;as the Core Ultra 7 155H&nbsp;has to fetch data from the DRAM.</p><p>Focusing on Translation Lookaside Buffer (TLB) performance, our data indicates the Core Ultra 7 155H suffers a&nbsp;latency penalty whenever a TLB miss occurs (TLB Penalty line), which aligns with the expected behavior when data&nbsp;extends beyond the cache. The latency further skyrockets whenever TLB misses, and the TLB+CLR Thrash line points&nbsp;towards worst-case scenarios in memory access.</p><p>As the test depth extends to 16384 KB and beyond, nearly all memory access patterns converge towards higher latencies, indicating&nbsp;the reliance on main memory as the cache sizes are exceeded. This suggests that despite increasing latency with larger caches within Meteor Lake's&nbsp;memory hierarchy, the Core Ultra 7 155H still benefits from an overall larger&nbsp;cache capacity, which should result in higher performance with data stored within the cache instead of accessing data externally.</p><p>The Meteor Lake memory subsystem is nearly identical to that we've seen on Raptor Lake via the Core i5-14600K, which is also highlighted, and it seems designed to optimize for larger cache capacities while trying to negate any trade-offs in latencies. The Core Ultra 7 155H CPU does seem to navigate&nbsp;these trade-offs, managing various access patterns with varying efficiency, at least within the 1024 KB testing depth and below.</p><p>In contrast to AMD's Phoenix mobile architecture using Zen 4, which closely resembles the cache of Zen 3, albeit with more L2 and an uptick in cycles, we can see a spike in TLB+CLR Thrashing compared to Meteor Lake. Still, inherently, below the 1024 KB test depth, both memory substructures on Meteor Lake and Phoenix remain competitive. Beyond 1024 KB, we see higher latencies, which is a direct result of crossing the L1 and L2 TLB thresholds at 112 KB of L1 per P-core and 2 MB of L2 per P-core.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH9yfpdrZqKmpJq5bq%2FOq5xmrZypv6J5lmZoam2YYr%2BmwsiermallamysL6MpZiknV2irqyx0makmqOVqHqnvsSsn2arpJa%2FtXnTqGSmp5KeuaZ5wqmsrGdj</p></div></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=./nec-ea244uhd-review.html rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Display Uniformity - NEC EA244UHD Review</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=./who-is-quick-flip-vino-man-arrested-for-trying-to-threaten-charleston-white.html rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>Who Is Quick Flip Vino? Man Arrested For Trying To Threaten Charleston White</p></a></div></nav></div><aside class=sidebar><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./asbjorn-krogh-nissen.html>Asbjrn Krogh Nissen Height, Weight, Size, Body Measurements, Biography, Wiki, Age</a></li><li class=widget__item><a class=widget__link href=./craig-federighi-bio-age-wiki-net-worth-salary-apple-wife-email-house-steve-jobs-and-family.html>Craig Federighi Bio, Age, Wiki, Net Worth, Salary, Apple, Wife, Email, House, Steve Jobs and Family</a></li><li class=widget__item><a class=widget__link href=./er-ejercito-net-worth-143173.html>ER Ejercito Net Worth</a></li><li class=widget__item><a class=widget__link href=./howard-baskin.html>Howard Baskin Wiki, Bio, Wiki, Age, Height, Weight, Wife, Net Worth, Parents, Facts</a></li><li class=widget__item><a class=widget__link href=./meghan-markle-dark-nail-polish-british-fashion-awards-royal-protocol.html>Meghan Markle Wears Dark Nail Polish</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./categories/blog/>blog</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 QuickBlog.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=https://assets.cdnweb.info/hugo/mainroad/js/menu.js></script>
<script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>